###################################################################
##### generate hierarchical clustering of the x.vs.y matrix #######
###################################################################
##Inputs: data_XY, model.on, stats.on, protein_pairs, cut tree height
#model.on <- "condition"; stats.on <- "condition"
if(!exists("verbose") || !is.logical(verbose)){verbose <- TRUE}
if (!exists("protein_pairs")) {stop("\nNo \"protein_pairs\" object found\n")}
if (!exists("Q")) { Q <- "__missing__"; warning("Q not found. Assigning as \"__missing__\". This will affect filenames of saved data")}
if (!exists("cutType")){ cutType <- "h_4"; warning("No cutType found. Using default h_4") } #defaults to height cutting at 4
if (!exists("l_save")){l_save <- TRUE}
if (!exists("l_centerPlots")){l_centerPlots <- TRUE}
if (!exists("l_export")){l_export <- FALSE}
if (!exists("l_sqrt_x")) { l_sqrt_x <- TRUE }
if (!exists("l_MfuzzPlot")) { l_MfuzzPlot <- FALSE }
he <- grepl("h", cutType); cutParam <- as.numeric(stringr::str_split(cutType, "_")[[1]][2])

### IK 2023-02-03 protein_pairs now has four columns that could potentially work as distances:
### * x.vs.y.11
### * x.vs.y.int
### * x.vs.y.F
### * x.vs.y.AIC
### choose one as the actual distance:
dist.method <- c("x.vs.y.11", "x.vs.y.int", "x.vs.y.F", "x.vs.y.AIC")[3]
protein_pairs$x.vs.y <- protein_pairs[, dist.method]
if (verbose) { cat("\nInfo (07_hclustProfiles.R): protein-to-protein distance will be taken from column", dist.method, "of the distance matrix\n") }

### IK 2023-03-27 cluster memberships are now a function of distances to the cluster center, and therefore can also be calculated in several ways
### here choose one to be used for memberships calculations:
mmbr.method <- c("intCoeff", "prismF", "prismAIC", "euclidean")[2]
if (verbose) { cat("\nInfo (07_hclustProfiles.R): using", mmbr.method, "method for membership value calculations\n") }

### remove NAs, clustering does not work with them
### when removing a certain pair, make sure to remove the entire protein because otherwise the matrix integrity may be compromised
while (TRUE) {
  nofNonNA <- data.frame(AC=protein_pairs$ACx, nofNonNA=as.numeric(!is.na(protein_pairs$x.vs.y)))
  nofNonNA <- aggregate(list(nofNonNA=nofNonNA$nofNonNA), by=list(AC=nofNonNA$AC), FUN="sum", na.rm=FALSE)
  if (min(nofNonNA$nofNonNA) == max(nofNonNA$nofNonNA)) break
  AC2remove <- nofNonNA$AC[nofNonNA$nofNonNA==min(nofNonNA$nofNonNA)]
  protein_pairs <- protein_pairs[!(protein_pairs$ACx %in% AC2remove), ]
  protein_pairs <- protein_pairs[!(protein_pairs$ACy %in% AC2remove), ]
  data_XY <- data_XY[!(data_XY$AC %in% AC2remove), ]
}

rm(nofNonNA) ; if (exists("AC2remove")) rm(AC2remove)

### replace possible Inf values
ixs <- is.infinite(protein_pairs$x.vs.y)
if (sum(ixs) > 0) {
  inf.replace <- max(protein_pairs$x.vs.y[!ixs]) * 1.01
  if (verbose) cat("\nInfo: ", sum(ixs), "distances are infinity, replacing with", inf.replace,"\n")
  protein_pairs$x.vs.y[ixs] <- inf.replace
}

### if data_XY does not contain p.pVal.adj, append it from protein_pairs
### except it might be incorrect - the right way to calculated the individual pVals is coded in answer_questions_*.R
if (sum(grepl("^p[.]pVal[.]adj$", colnames(data_XY)))<1) {
  tmp <- protein_pairs[, c("ACx", "p.pVal.x")] ; tmp <- tmp[!duplicated(tmp$ACx), ] ; colnames(tmp) <- c("AC", "p.pVal.adj")
  data_XY <- plyr::join(tmp, data_XY, by="AC", type="left"); rm(tmp)
}
sigCol <- "p.pVal.adj"

l_zScore <- FALSE ; mu <- 0. ; sigma <- 1
if (l_zScore) {
  mu <- base::mean(protein_pairs$x.vs.y[protein_pairs$x.vs.y != "Inf"])
  sigma <- sd(protein_pairs$x.vs.y[protein_pairs$x.vs.y != "Inf"], na.rm = TRUE) }
nprot <- nrow(data_XY) ### length(unique(protein_pairs$ACy))
vs_mat <- matrix((protein_pairs$x.vs.y-mu)/sigma, nrow=nprot, ncol=nprot, dimnames=list(unique(protein_pairs$ACx), unique(protein_pairs$ACy)))
clMethod <- c("ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median", "centroid")[4] ### "average"=UPGMA, "mcquitty"=WPGMA, "median"=WPGMC, "centroid"=UPGMC
hc <- stats::hclust(stats::as.dist(vs_mat), method=clMethod)


he_old <- he; cutParam_old <- cutParam
while (TRUE){
  #### 2023-02-03 experimenting, the DM was calculated by "condition" thus there are too many options for distinct profiles
  if (he) { ### cut the tree at the specified height
    clustering <- stats::cutree(hc, h=cutParam); cat(paste0("\nInfo (07_hclustProfiles.R): ", length(unique(clustering)), " clusters generated at cut height ", cutParam, "\n"))
  } else { ### cut the tree at a height that generates a specified number of clusters
    clustering <- stats::cutree(hc, k=cutParam); cat(paste0("\nInfo (07_hclustProfiles.R): ", length(unique(clustering)), " clusters generated by manually specified # of clusters\n"))
  }
  clustering <- as.numeric(clustering); #AL: simplify data structure to speed up function calls

  ########################################################################
  ###################### calculate cluster centers #######################
  ############### as averages of all proteins in the cluster #############
  ######################### weighted by "w" ##############################
  ########################################################################

  ### mean-center the data for determining cluster centers
  data_XY_meanCentered <- data_XY ;
  data_XY_meanCentered[, unique(semantics_XY$sample)] <- data_XY_meanCentered[, unique(semantics_XY$sample)] - rowMeans(data_XY_meanCentered[, unique(semantics_XY$sample)], na.rm=TRUE)

  ### build data_avg: average profiles of the individual proteins, centered at 0 - previously called dm
  ### also build semantics_avg
  conds <- unique(semantics_XY$condition)
  data_avg <- data.frame(AC=data_XY$AC, protein=data_XY$protein)
  for (cond in conds) { data_avg[, cond] <- rowMeans(data_XY[, semantics_XY$sample[semantics_XY$condition==cond]], na.rm=TRUE) }
  data_avg[, conds] <- data_avg[, conds] - rowMeans(data_avg[, conds], na.rm=TRUE)
  semantics_avg <- semantics_XY[!duplicated(semantics_XY$condition), ] ; semantics_avg$sample <- semantics_avg$condition
  #plotPoint(data_XY [order(data_XY[, sigCol], decreasing=TRUE)[1:9], ], semantics_XY, ncol=3, legendPos="bottom")
  #plotPoint(data_avg[order(data_XY[, sigCol], decreasing=TRUE)[1:9], ], semantics_avg, ncol=3, legendPos="bottom")

  ### calculate "thick" and "thin" (IK & AL versions, respectively) cluster centers
  ### thin is needed for the conversion to mfuzz section of script
  ### thick for statistical distance calculation
  centersThin  <- data_avg[1:max(clustering), c("AC", semantics_avg$sample)] ;
  centersThick <- data_XY [1:max(clustering), c("AC", semantics_XY$sample)] ;
  w <- data_XY[, sigCol]
  for (cl in unique(clustering)){
    centersThick$AC[cl] <- paste0("cluster ", cl) ; centersThin$AC[cl] <- paste0("cluster ", cl)
    ixs <- clustering==cl & !is.na(w)
    if (sum(ixs)>0) { ### have some non-NA p.pVals in this cluster, calculate weighted average
      for (colnm in semantics_XY$sample)  centersThick[cl, colnm] <- stats::weighted.mean(data_XY_meanCentered[ixs, colnm], w[ixs], na.rm=TRUE)
      for (colnm in semantics_avg$sample) centersThin [cl, colnm] <- stats::weighted.mean(data_avg[ixs, colnm], w[ixs], na.rm=TRUE)
    } else { ### all p.pVals in this cluster are NA (but its members somehow did not get deleted anyways), calculate regular average
      ixs <- clustering==cl
      for (colnm in semantics_XY$sample)  centersThick[cl, colnm] <- mean(data_XY_meanCentered[ixs, colnm], na.rm=TRUE)
      for (colnm in semantics_avg$sample) centersThin [cl, colnm] <- mean(data_avg[ixs, colnm], na.rm=TRUE)
    }
  }

  ### In the rare case that a center is completely zero across all peptides for a condition, it needs to be removed
  for (cond in unique(semantics_XY$condition)) {
    zeroConds <- rowSums(centersThick[ , semantics_XY$sample[semantics_XY$condition == cond]], na.rm = TRUE) == 0
    if (sum(zeroConds) > 0){
      if (verbose) cat("The following clusters are missing data for an entire condition and are unresolvable:", centersThick$AC[zeroConds], "\n")
      centersThick <- centersThick[!zeroConds, ]
      centersThin <- centersThin[!zeroConds, ]
    }
  }

  if (nrow(centersThick) == max(unique(clustering))){
    break
  }else{
    cat("Recutting tree to produce smaller number of clusters. This is due to unresovability of protein vs cluster centers.\n")
    cat("Previous num of clusters:", max(unique(clustering)), "\n")
    cat("New num of clusters:", nrow(centersThick), "\n")
    he <- FALSE; cutParam <- nrow(centersThick)
  }
}
##231226 AL: We likely don't want to replace the new cut with the old one. What's saved should be representative of what was actually performed
#if (exists("he_old") & exists("cutParam_old")){ he <- he_old; cutParam <- cutParam_old; rm(he_old, cutParam_old)}

########################################################################
### create the plot output directory (if needed) and clean it up #######
########################################################################

oufnm <- paste0(dirOut, "/clusters_", Q, "/cl_.png")
if (!dir.exists(dirname(oufnm))) { dir.create(dirname(oufnm), recursive=TRUE) }
filenms <- list.files(dirname(oufnm), full.names=TRUE)
filenms <- filenms[!grepl("center", filenms)] #Prevents removal of center plots, if they exist
filenms <- filenms[grepl(".png", filenms, fixed=TRUE)] ;
tmp <- do.call(file.remove, list(filenms)) ; rm(tmp)

### semantics_2 is a semantics df for plotting cell lines in two colors with response curves
semantics_2 <- semantics_XY
if (length(unique(semantics_XY$time))>1) semantics_2$condition <- semantics_2$time
if (length(unique(semantics_XY$cell_line))>1) semantics_2$plex <- semantics_2$cell_line else
if (length(unique(semantics_XY$ligand))>1) semantics_2$plex <- semantics_2$ligand else
if (length(unique(semantics_XY$pretreatment))>1) semantics_2$plex <- semantics_2$pretreatment

if (l_centerPlots) {
  ncol.on.page <- 8
  thickPlot  <- ProteomicsToolkit::lplot(centersThick[1:max(clustering), ], semantics_XY  , maxPoints=max(clustering), legendPos="none")
  thickPlot2 <- ProteomicsToolkit::lplot(centersThick[1:max(clustering), ], semantics_2   , maxPoints=max(clustering), legendPos="bottom", x_sqrt_scale = TRUE)
  thinPlot   <- ProteomicsToolkit::lplot(centersThin [1:max(clustering), ], semantics_avg , maxPoints=max(clustering), legendPos="none")
  if (l_export){
    if (!exists("centerEnv")){centerEnv <- new.env()}
    if (TRUE){for (center in c("thickPlot", "thickPlot2", "thinPlot")) { if (!exists(center)) next ; assign(paste0(Q,"_center_", center), get(center), envir = centerEnv)}}
    save(list = c("thickPlot", "thickPlot2", "thinPlot"), file = paste0(dirOut, "/clusters_", Q, "/", "all_centers.Rdata" ))
  } else {
    thickPlot  <- ProteomicsToolkit::plotPoint(ncol=ncol.on.page, plotlist = thickPlot)
    thickPlot2 <- ProteomicsToolkit::plotPoint(ncol=ncol.on.page, plotlist = thickPlot2)
    thinPlot   <- ProteomicsToolkit::plotPoint(ncol=ncol.on.page, plotlist = thinPlot)
    for (center in c("thickPlot", "thickPlot2", "thinPlot")) { if (!exists(center)) next ;
      # oufnm <- paste0(dirOut, "/clusters_", Q, "/", "center_", center, ".png" )
      print(max(clustering))
      ouext <- ifelse(max(clustering) <= 90, ".png", ".pdf")
      oufnm <- paste0(dirOut, "/clusters_", Q, "/", "center_", center, ouext)
      if (max(clustering) <= 90) {
        ggplot2::ggsave(oufnm, get(center), width=ncol.on.page, height=ceiling(max(clustering)/ncol.on.page), units="in", scale=3, limitsize=FALSE)
      } else {
        ggplot2::ggsave(oufnm, get(center), width=ncol.on.page, height=5, units="in", scale=3, limitsize=FALSE)  # for ease of plotting, set height == number of rows in marrangeGrob (used in plotpoint)
      }
    }
  }
  #nms <- c("center", "thickPlot", "thickPlot2", "thinPlot", "l_centerPlots") ; nms <- nms[nms %in% ls()] ; if (length(nms)>0) rm(list=nms) ; rm(nm)
}

centersThick <- within(centersThick, rm(AC)) ; centersThin <- within(centersThin, rm(AC))
rm(data_XY_meanCentered, conds)

########################################################################
############### determine protein membership in the clusters ###########
########################################################################
### 2023-02-15 IK implementing this in a way that gets a matrix of memberships - each protein in each cluster
### This can be done in several ways:
###  * statistical differences from centersThick via interaction coeff, F-test, or AIC:
###    - int coeff & F-test are on p.pVal scale; AIC on log odds scale, all need to be converted into 0:1 somehow
###  * Euclidean distances from centersThin
###    - these are on, well Euclidean distance scale and also need to be converted into 0:1
###  * (not ideal) just sigCol for cluster members, 0 for non-members
###    - also needs to be made into 0:1
########################################################################

### determine how "strict" the membership requirements are going to be
sigCutoff <- 0.05 ; p.pVal.cutoff <- -log10(sigCutoff) ### sigCutoff=0.05 means everything that is distinct from a cluster center with p<0.05 is considered a member of that cluster
### decrease sigCutoff to make the "distinct" criterion more strict and therefore cluster membership more permissive
### sounds a little counter-intuitive but this is correct, lower sigCutoff means more permissive clustering, membership-wise

### initialize the membership matrices
mtx <- matrix(nrow=nprot, ncol=max(clustering), dimnames=list(data_XY$AC, unique(clustering)))
dist_manhattan <- mtx ; dist_euclidean <- mtx ; dist_intCoeff <- mtx ; dist_prismF <- mtx ; dist_prismAIC <- mtx ; dist_p.pVal <- mtx;
rm(mtx)

### calculate the distances in six ways
conds <- unique(semantics_XY$condition)
if (verbose) cat(paste0("\nInfo (07_hclustProfiles.R): calculating membership matrices (6 varieties) for ", length(unique(clustering)), " cluster(s)\n"))

#saveState()

for (cln in unique(clustering)) {
  if (verbose) cat(paste0(" * Cluster ", cln ,": ", sum(clustering==cln), " members\n"))
  ### dist_p.pVal: the simplistic p.pVal.adj - based "membership" (so, actually, NOT a distance)
  dist_p.pVal[, cln] <- as.numeric(clustering==cln) * data_XY[, sigCol] ### 0 for non-cluster members, sigCol for cluster members
  dist_p.pVal[is.na(data_XY[, sigCol]), cln] <- 0

  ### dist_euclidean: Euclidean distance from the thin center center
  dist_euclidean[, cln] <- sqrt(rowSums((data_avg[, conds] - centersThin[rep(cln, nrow(data_avg)), conds])^2, na.rm=TRUE))

  ### dist_manhattan: Manhattan distances from the thin cluster center
  dist_manhattan[, cln] <- rowSums(abs(data_avg[, conds] - centersThin[rep(cln, nrow(data_avg)), conds]), na.rm=TRUE)

  ### append to data_var the center of cluster cln
  data_var <- data_XY
  data_cntr <- centersThick[rep(cln, nrow(data_var)), ] ; colnames(data_cntr) <- paste0("cntr_", colnames(data_cntr))
  data_var <- cbind(data_var, data_cntr); rm(data_cntr)

  ### append the center rows to semantics_var_plot too
  semantics_var_plot <- semantics_XY ; semantics_var_plot$plex <- "data"
  semantics_cntr <- semantics_var_plot ; semantics_cntr$sample <- paste0("cntr_", semantics_cntr$sample) ; semantics_cntr$plex <- "cntr"
  semantics_var_plot <- rbind(semantics_var_plot, semantics_cntr) ; rm(semantics_cntr)

  ### dist_intCoeff : statistical distance from the thick cluster centers via interaction coeff
  ### calculate ANOVA "separate" fit, get the interaction coefficients


  separate <- step06_ANOVA(data_var, semantics_var_plot, model.on="condition*plex", stats.on="condition:plex", verbose=FALSE, splineDF=splineDF)
  dist_intCoeff[, cln] <- separate[["condition:plex"]]$p.pVal.adj

  ### dist_prismF   : statistical distance from the thick cluster centers via F-test
  ### dist_prismAIC : statistical distance from the thick cluster centers via AIC
  ### calculate ANOVA "collated" fit, get the prism F-test and AIC
  collated <- step06_ANOVA(data_var, semantics_var_plot, model.on="condition+plex", stats.on="_term_", verbose=FALSE, splineDF=splineDF)
  separatefp <- separate$fit.properties ; collatedfp <- collated$fit.properties ;
  F <- ((collatedfp$ss-separatefp$ss)/(collatedfp$df.residual-separatefp$df.residual)) / (separatefp$ss/separatefp$df.residual)
  dfn <- collatedfp$df.residual-separatefp$df.residual ; dfd <- separatefp$df.residual ;
  dist_prismF[, cln] <- -log10(pf(F, dfn, dfd, lower.tail=FALSE)) ; rm(F, dfn, dfd)
  dAIC <- separatefp$AICc - collatedfp$AICc ### corrected - for the peptide-level scenario; for the projected scenario the correction factor is negligible i.e. AICc still works
  dist_prismAIC[, cln] <- -dAIC/2*log10(exp(1)) ### probability ratio of separate model being correct vs incorrect
  AICoffset <- -0.4462*p.pVal.cutoff+2.33291 ; dist_prismAIC[, cln] <- dist_prismAIC[, cln] + AICoffset ### this adjusts how low the log-odds should be for us to say it is the same response as the cluster center. 2.2 makes it close to Ftest on mem scale
  dist_prismAIC[!is.na(dist_prismAIC[, cln]) & dist_prismAIC[, cln]<0., cln] <- 0.
  rm(dAIC, collatedfp, separatefp)

  rm(data_var, semantics_var_plot)
}



### convert p.pVal-scale *distances* into *memberships* distributed in [0., 1.]
### this is done through a function mmbr=exp.base^(-dist^exp.exp)
### exp.exp is an adjustable parameter that controls steepness
### exp.base is selected in a way that ensures that significance sigCutoff (or p.pVal.cutoff on the -log10 scale) translates into membership of 0.5
exp.exp <- 6 ### 8 is steep, decrease if you want it smoother. MUST BE EVEN TO WORK.
exp.base <- exp(log(0.5)/(-p.pVal.cutoff^exp.exp))
frac_assigned <- sum(dist_intCoeff<p.pVal.cutoff | dist_prismF<p.pVal.cutoff | dist_prismAIC<p.pVal.cutoff) / (nrow(dist_intCoeff)*ncol(dist_intCoeff))

mmbr_p.pVal   <- 1-exp.base^(-dist_p.pVal  ^exp.exp) ### significance equal to p.pVal.cutoff will be converted into "membership" 0.5
mmbr_intCoeff <-   exp.base^(-dist_intCoeff^exp.exp) ### distance equal to p.pVal.cutoff will be converted into membership 0.5
mmbr_prismF   <-   exp.base^(-dist_prismF  ^exp.exp) ### distance equal to p.pVal.cutoff will be converted into membership 0.5
mmbr_prismAIC <-   exp.base^(-dist_prismAIC^exp.exp) ### distance equal to p.pVal.cutoff will be converted into membership 0.5

if (FALSE) { ### original way of converting euclidean and manhattan distances into memberships
  dist_05_95 <- stats::quantile(dist_euclidean, probs=c(0.05, 0.95), na.rm=TRUE)
  mmbr_euclidean <- (dist_05_95[2]-dist_euclidean)/(dist_05_95[2]-dist_05_95[1])
  mmbr_euclidean[mmbr_euclidean < 0.] <- 0. ; mmbr_euclidean[mmbr_euclidean > 1.] <- 1.

  dist_05_95 <- stats::quantile(dist_manhattan, probs=c(0.05, 0.95), na.rm=TRUE)
  mmbr_manhattan <- (dist_05_95[2]-dist_manhattan)/(dist_05_95[2]-dist_05_95[1])
  mmbr_manhattan[mmbr_manhattan < 0.] <- 0. ; mmbr_manhattan[mmbr_manhattan > 1.] <- 1. ; rm(dist_05_95)
} else {
  dist_cutoff <- stats::quantile(dist_euclidean, probs=frac_assigned, na.rm=TRUE)
  dist_euclidean <- (dist_euclidean/dist_cutoff)*p.pVal.cutoff ### bring euclidean distances in a range comparable to p.pVals
  mmbr_euclidean <- exp.base^(-dist_euclidean^exp.exp)

  dist_cutoff <- stats::quantile(dist_manhattan, probs=frac_assigned, na.rm=TRUE)
  dist_manhattan <- (dist_manhattan/dist_cutoff)*p.pVal.cutoff ### bring manhattan distances in a range comparable to p.pVals
  mmbr_manhattan <- exp.base^(-dist_manhattan^exp.exp) ; rm(dist_cutoff)
}

memCutoff = 0.5
if (verbose) {
  cat(paste0("\n", sum(rowSums(mmbr_p.pVal    > memCutoff) > 0), " of ", nrow(data_XY), " proteins are assigned to clusters with membership > ", memCutoff, " using p.pVal.adj"))
  cat(paste0("\n", sum(rowSums(mmbr_intCoeff  > memCutoff) > 0), " of ", nrow(data_XY), " proteins are assigned to clusters with membership > ", memCutoff, " using intCoeff-based membership"))
  cat(paste0("\n", sum(rowSums(mmbr_prismF    > memCutoff) > 0), " of ", nrow(data_XY), " proteins are assigned to clusters with membership > ", memCutoff, " using prismF-based membership"))
  cat(paste0("\n", sum(rowSums(mmbr_prismAIC  > memCutoff) > 0), " of ", nrow(data_XY), " proteins are assigned to clusters with membership > ", memCutoff, " using prismAIC-based membership"))
  cat(paste0("\n", sum(rowSums(mmbr_euclidean > memCutoff) > 0), " of ", nrow(data_XY), " proteins are assigned to clusters with membership > ", memCutoff, " using euclidean distances"))
  cat(paste0("\n", sum(rowSums(mmbr_manhattan > memCutoff) > 0), " of ", nrow(data_XY), " proteins are assigned to clusters with membership > ", memCutoff, " using manhattan distances"))
}

#############################################################################################
### (optional/debugging) plots to illustrate the relatedness (or the absence of thereof) ####
### of different memberships ################################################################
#############################################################################################
if (FALSE) { ###
  plot(mmbr_p.pVal, mmbr_euclidean)
  plot(mmbr_p.pVal, mmbr_intCoeff)
  plot(mmbr_p.pVal, mmbr_prismF)
  plot(mmbr_p.pVal, mmbr_prismAIC)

  plot(mmbr_euclidean, mmbr_intCoeff) ### no agreement
  plot(mmbr_euclidean, mmbr_prismF)   ### no agreement
  plot(mmbr_euclidean, mmbr_prismAIC) ### no agreement

  plot(mmbr_intCoeff, mmbr_prismF)    ### some loose agreement
  plot(mmbr_intCoeff, mmbr_prismAIC)  ### some loose agreement
  plot(mmbr_prismF  , mmbr_prismAIC)  ### clearly related but non-linearly, with the AICoffset correction above - close
}

#############################################################################################
### (optional/debugging) for the desired ACxcl "distance to the center of the cluster" matrix
### * plot a histogram of all distances
### * plot a histogram of distances to the closest/cognate cluster center
#############################################################################################
if (FALSE) {
  ### first build a matrix of 1's and 0's describing the hard cluster membership in accordance with clustering
  mtx <- matrix(nrow=nprot, ncol=max(clustering), dimnames=list(data_XY$AC, unique(clustering)))
  for (cl in 1:max(clustering)) { mtx[, cl] <- as.numeric(clustering==cl) }

  ixs <- (!is.na(data_XY$p.pVal.adj)) & (data_XY$p.pVal.adj > 1.3)
  #ixs <- ixs | !ixs ### this will make it into all TRUE's

  for (me in c("p.pVal", "intCoeff", "prismF", "prismAIC", "euclidean", "manhattan")) {
    #me <- c("p.pVal", "intCoeff", "prismF", "prismAIC", "euclidean")[2]
    plotlist <- list() ; ix <- 0
    for (pt in c("Distance from all cluster centers", "Distance from cognate cluster center", "Aggregated distance from cognate cluster center", "Membership in all clusters", "Membership in cognate cluster", "Aggregated membership in cognate cluster")) {
      #pt <- c("Distance from all cluster centers", "Distance from cognate cluster center", "Membership in all clusters", "Membership in cognate cluster")[2]

      xmin <- -0.5
      if (grepl("istance", pt)) { m <- get(paste0("dist_", me)) ; xmax <- 5.5 } else { m <- get(paste0("mmbr_", me)) ; xmax <- 1.5 }
      if (!grepl("cognate", pt)) {
        cl <- 16 ; tmp <- data.frame(AC=rownames(m)[ixs], cl=clustering[ixs], fixedCl=m[ixs,cl], cogCl=rowSums(m * mtx)[ixs]) ### fixedCl is distance to cluster cl center (or membership in that cluster), cogCl is distance to cognate cluster center (or membership in it)
        plot(x=tmp$fixedCl, y=tmp$cogCl, col=factor(tmp$cl==cl), xlim=c(xmin,xmax), ylim=c(xmin,xmax), main=me) ; rm(tmp)

        m <- reshape2::melt(m[ixs,]) ; colnames(m) <- c("AC", "cl", "value") ; m <- m[!is.na(m$value), ]
      } else {
        if (grepl("ggregated", pt)) { m <- data.frame(AC=rownames(m)[ixs], cl="cognate", value=rowSums(m * mtx)[ixs])
        } else { m <- data.frame(AC=rownames(m)[ixs], cl=clustering[ixs], value=rowSums(m * mtx)[ixs]) }
      }
      m$cl <- factor(m$cl)

      g <- (ggplot2::ggplot(m, mapping=ggplot2::aes(x=value, color=cl)) +
            ggplot2::geom_freqpoly(binwidth=0.1) +
            ggplot2::labs(x="value", y="frequency", title=paste0(pt, " - ", me)) +
            ggplot2::xlim(xmin, xmax))
      ix <- ix+1 ; plotlist[[ix]] <- g
    }
    g <- cowplot::plot_grid(plotlist=plotlist, ncol=3, scale=1.)
    oufnm <- paste0(dirOut, "/images/", me, ".png") ; ggplot2::ggsave(oufnm, g, width=6, height=3, units="in", scale=3, limitsize=FALSE)
    #print(g)
  }

  if (FALSE) { ### plotPoint for representative outliers
    m <- dist_intCoeff
    cl <- 16 ; tmp <- data.frame(AC=rownames(m)[ixs], cl=clustering[ixs], fixedCl=m[ixs,cl], cogCl=rowSums(m * mtx)[ixs]) ### fixedCl is distance to cluster cl center (or membership in that cluster), cogCl is distance to cognate cluster center (or membership in it)
    ProteomicsToolkit::plotPoint(data_XY[data_XY$AC %in% tmp$AC[tmp$fixedCl < tmp$cogCl-1.], ], semantics_XY, ncol=7, maxPoints=16, legendPos="bottom", x_sqrt_scale = l_sqrt_x)
  }
}

################################################################################################
###### finalize memberships and significances for enrichment/over-representation analysis ######
################################################################################################

### first decide which cluster membership definition to use
### as a reminder, dist.method is one of c("x.vs.y.11", "x.vs.y.int", "x.vs.y.F", "x.vs.y.AIC")
### but these memberships are kinda independent... maybe they should not be
if (mmbr.method == "intCoeff" ) mmbr <- mmbr_intCoeff
if (mmbr.method == "prismF"   ) mmbr <- mmbr_prismF
if (mmbr.method == "prismAIC" ) mmbr <- mmbr_prismAIC
if (mmbr.method == "euclidean") mmbr <- mmbr_euclidean

### convert all significances into membership scale, combine with memberships, and convert back
tmp_p.pVal <- data_XY[, rep(sigCol, ncol(mmbr))] ; tmp_p.pVal <- 1-exp.base^(-tmp_p.pVal^exp.exp)
colnames(tmp_p.pVal) <- colnames(mmbr) ; rownames(tmp_p.pVal) <- rownames(mmbr)
tmp_p.pVal[is.na(tmp_p.pVal)] <- 0. ### unestimable own pVals are replaced by "no significance"
### mmbr is membership but taking into account own p.pVal (low if p.pVal is low)
mmbr <- sqrt(mmbr * tmp_p.pVal) ; colnames(mmbr) <- colnames(tmp_p.pVal) ; rownames(mmbr) <- rownames(tmp_p.pVal)
if (verbose) {cat("\nPercentage of ACs that do not have a value > 0 in at least one cluster:", sum(rowSums(mmbr) == 0) / nrow(mmbr))}
### cl_p.pVal is significance but taking into account membership (low if membership is low)
cl_p.pVal <- (-log(1.000-0.99999*mmbr)/log(exp.base))^(1/exp.exp) ; colnames(cl_p.pVal) <- colnames(tmp_p.pVal) ; rownames(cl_p.pVal) <- rownames(tmp_p.pVal)
rm(tmp_p.pVal)

################################################################################################
###################### plot response profiles of cluster members ###############################
################################################################################################

############# old way - this is a function which is nice ###############
############## may want to merge with the new way below ################
clusterMembers <- function(data, semantics, mem.mat, cl.num=NA, nof.top=3, mem.cutoff=0., l_plot=FALSE, l_sqrt_x=FALSE) {
  if (nrow(mem.mat) != nrow(data)) { return("Error: mem.mat dimensions do not match data") }
  if (is.na(cl.num)) { cl.num <- 1:ncol(mem.mat) } ; cl.num <- cl.num[cl.num %in% 1:ncol(mem.mat)]
  if (length(cl.num) == 0) { return("Error: no such clusters in mem.mat") }
  if (is.na(nof.top)) { nof.top <- nrow(data) } ; if (is.na(mem.cutoff)) { mem.cutoff <- 0. }

  for (cln in cl.num) {
    tmp <- data.frame(row=rownames(data), protein=data$protein, mem=mem.mat[, cln]) ; tmp <- tmp[order(tmp$mem, decreasing=TRUE), ] ; tmp$cnt <- 1:nrow(tmp)
    tmp <- tmp[tmp$mem > mem.cutoff, ] ; tmp <- tmp[tmp$cnt <= nof.top, ]
    cat(paste0("\n  Cluster ", cln, ": ", paste0(tmp$protein, collapse=",")))
    if (l_plot & (nrow(tmp)>0)) { for (ix in 1:nrow(tmp)) { ProteomicsToolkit::plotPoint(data, semantics, tmp$row[ix], x_sqrt_scale = l_sqrt_x) } }
    rm(tmp)
  }
}
#clusterMembers(data_XY, semantics_XY, mmbr, cl.num=1, nof.top=10, mem.cutoff=memCutoff, l_plot=TRUE)

############# "new" way - just a loop with plotPoint calls() ##############
if (TRUE) {
maxnplots <- 40 ; ncol.on.page <- 8 ; if (verbose) cat(paste0("\n\nInfo (07_hclustProfiles.R): plotting\n"))
for (cln in unique(clustering)) {
  n <- sum(!is.na(cl_p.pVal[, cln]) & cl_p.pVal[, cln]>p.pVal.cutoff) ; ixs <- order(cl_p.pVal[, cln], decreasing=TRUE)
  if (n < 1) { if (verbose) cat(paste0(" * Cluster ", cln ,": no significant members\n")) ; next }
  if (verbose) cat(paste0(" * Cluster ", cln ,": ", n, " significant member(s), plotting\n"))

  g <- ProteomicsToolkit::plotPoint(data_XY[ixs,], semantics_2, maxPoints=min(maxnplots, n), ncol=ncol.on.page, legendPos="none", x_sqrt_scale = l_sqrt_x)
  n.char <- ceiling(log10(max(clustering)+1)) ### "001" or similar
  oufnm <- paste0(dirOut, "/clusters_", Q, "/cl_", substr(as.character(10^n.char+cln), 2, 1+n.char),".png")

  ggplot2::ggsave(oufnm, g, width=ncol.on.page, height=ceiling(min(maxnplots, n)/ncol.on.page), units="in", scale=3, limitsize=FALSE)
  if (n < 2) ggplot2::ggsave(oufnm, g, width=1, height=1, units="in", scale=3, limitsize=FALSE)

  rm(semantics_tmp)
}
}

###########################################################################
############################### Mfuzz way #################################
#### generate a mimic of the fdm data structure for Mfuzz plotting ########
#### but use the cluster membership definition as above ###################
###########################################################################

### build fdm (the actual cluster structure)
### it will have fdm$centers, fdm$size, fdm$cluster, fdm$membership, fdm$iter, fdm$withinerror, fdm$call
szs <- unique(clustering) ### this is just to initialize
for (cln in unique(clustering)) { szs[cln] <- sum(mmbr[, cln] > memCutoff, na.rm = TRUE) }

### build fdm
fdm <- list(centers=centersThin, size=szs, cluster=clustering, membership=mmbr, iter=NA, withinerror=memCutoff/(memCutoff+1), call="")
names(fdm$cluster) <- 1:nrow(data_XY)
if (FALSE) { ### pre-2023-03 method of pVals-to-membership conversion, using the signiAndScore function
  sigCol <- "p.pVal.adj"
  mmbr_pValScale <- matrix(nrow=nprot, ncol=max(clustering), dimnames=list(1:nrow(data_XY), unique(clustering)))
  #sigCutoff <- 0.05 #; memCutoff <- 0.5
  for (cln in unique(clustering)) {
    D <- ProteomicsToolkit::signiAndScore(data.frame(V1=data_XY[, sigCol], V2=mmbr[, cln]), sigCutoff=sigCutoff, mode="rational", l_graph=FALSE)
    mmbr[, cln]  <- D$score ### this number is on the scale of membership 0-1
    mmbr_pValScale[, cln] <- sigCutoff^(D$signi*mmbr[, cln]/memCutoff) ### this number is on the scale of pVal but bounded and corrected by membership
    mmbr_pValScale[, cln] <- -log10(mmbr_pValScale[, cln])
  }
  fdm$membership <- mmbr ; fdm$withinerror=memCutoff/(memCutoff+1)
  #fdm$membership <- mmbr_pValScale ; memCutoff <- -log10(0.05) ; fdm$withinerror=memCutoff/(memCutoff+1)
  #fdm$membership <- fdm$membership / (1+memCutoff) ; fdm$membership[fdm$membership>1.] <- 1.
}

###########################################################
######### plot clusters using Mfuzz::mfuzz.plot2 ##########
###########################################################
if (l_MfuzzPlot) {
  library(Biobase)

  ### what used to be dm in Mfuzz is our data_avg
  #AC_prot <- data_XY[, c('AC', 'protein')] #; dm <- within(dm, rm(AC, protein)) ; rm(cond0)
  ### melt documentation: https://www.rdocumentation.org/packages/reshape2/versions/1.4.4/topics/melt.data.frame
  tmp <- reshape2::melt(data_avg, measure.vars=conds)$value ; tmp <- tmp[!is.na(tmp)] ; tmp <- quantile(tmp, probs=c(0.001, 0.999)) ; minQuant <- tmp[1] ; maxQuant <- tmp[2] ; rm(tmp)
  maxQuant <- ceiling(maxQuant * 10.)/10. ; minQuant <- floor(minQuant * 10.)/10.

  dm <- Biobase::ExpressionSet(as.matrix(data_avg[,conds]))
  plotsPerRow <- 4 ; plotRows <- 3 ### plot layout on a page, will use multiple pages if needed
  fdm$iter <- 1 #Needs to have a dummy value here for iterations. This refers to generation of clusters using Mfuzz, which is not employed here.
  if (sum(is.na(as.numeric(conds))) > 0) { #Top block is using just categories for drawing clusters, the bottom block will have a time accurate x axis
    p <- Mfuzz::mfuzz.plot2(dm, cl=fdm, mfrow=c(plotRows,plotsPerRow), min.mem=memCutoff/(memCutoff+1), time.labels=conds, ylim.set=c(minQuant, maxQuant), xlab=c("time"), ylab=c("Quant Changes"), x11=TRUE, Xwidth=1200, Xheight=1200, colo="fancy")
  } else {
    p <- Mfuzz::mfuzz.plot2(dm, cl=fdm, mfrow=c(plotRows,4), min.mem=memCutoff/(memCutoff+1), time.labels=as.numeric(conds), time.points=as.numeric(conds), ylim.set=c(minQuant, maxQuant), xlab=c("time"), ylab=c("Quant Changes"), x11=TRUE, Xwidth=1200, Xheight=1200)
  }
  devlist <- dev.list()
  for (p in 1:length(devlist)) {
    dev.set(devlist[p])
    dev.print(pdf, paste0(dirOut, "/07_hclustProfiles_", Q, "_p", p, ".pdf"), width=plotsPerRow*3, height=plotRows*3)
    dev.off(devlist[p])
  }
  pages <- paste0(dirOut, "/07_hclustProfiles_", Q, "_p", 1:length(devlist), ".pdf")
  tmp <- qpdf::pdf_combine(input=pages, output=paste0(dirOut, "/07_hclustProfiles_", Q,".pdf"))
  tmp <- do.call(file.remove, list(pages)) ; rm(tmp, p, devlist)
}

if (l_save) {save(list=c("data_XY", "semantics_XY", "semantics_2", "clustering", "mmbr", "cl_p.pVal", "fdm", "hc", "cutType", "Q", "p.pVal.cutoff"), file=paste0(dirOut, '/07_hclustProfiles_', Q, '.Rdata'))}

#########################################################################
############################## UMAP #####################################
### https://cran.r-project.org/web/packages/umap/vignettes/umap.html ####

if (FALSE) { ###
  #U <- umap::umap(vs_mat, config=custom.config, input="dist")
  U <- umap::umap(vs_mat, input="dist", n_neighbors = 15L)

  layout <- U$layout ; xylim <- range(layout) ; pad <- 0.1 ; xylim = xylim + ((xylim[2]-xylim[1])*pad)*c(-0.5, 0.5)
  par(mar=c(0.2,0.7,1.2,0.7), ps=10) ; plot(xylim, xylim, type="n", axes=F, frame=F)
  rect(xylim[1], xylim[1], xylim[2], xylim[2], border="#aaaaaa", lwd=0.25)
  cex=0.6; pch=19; legend.suffix=""; cex.main=1; cex.legend=0.85

  clrs <- grDevices::rainbow(max(clustering))
  points(layout[,1], layout[,2], col=clrs[clustering], cex=cex, pch=pch)
  legend("topleft", as.character(unique(clustering)), inset=0.03, col=clrs[unique(clustering)], bty="n", pch=pch, cex=cex.legend)

  mtext(side=3, "A UMAP visualization", cex=cex.main)
}

### clear the environment
nms <- c("vs_mat", "collated", "separate", "AICoffset", "centersThick", "centersThin", "clMethod", "data_avg", "cl", "cln", "clnm", "clusterMembers", "colnm", "cond", "conds")
if (!l_export) {nms <- c(nms, "clustering", "dm", "fdm", "hc")}
nms <- c(nms, "dist_euclidean", "dist_intCoeff", "dist_manhattan", "dist_p.pVal", "dist_prismAIC", "dist_prismF", "exp.base", "exp.exp", "frac_assigned")
nms <- c(nms, "he", "ixs", "l_zScore", "maxnplots", "maxQuant", "minQuant", "mmbr_euclidean", "mmbr_intCoeff", "mmbr_manhattan", "mmbr_p.pVal", "mmbr_prismAIC", "mmbr_prismF")
nms <- c(nms, "model.on", "stats.on", "mu", "sigma", "n", "nprot", "plotRows", "oufnm", "szs", "w", "p")
nms <- c(nms, "center", "thickPlot", "thickPlot2", "thinPlot")

# nms <- nms[nms %in% ls()] ; if (length(nms)>0) rm(list=nms) ; rm(nms)
