#####################################################################################################################
### Inputs:
### * mmbr ### a matrix of memberships but taking into account own p.pVal (low if p.pVal is low); generated by the 07_hclustTimeCourses.R script
### * cl_p.pVal ### a matrix of -log10 significances but taking into account membership (low if membership is low)
### * data_XY - corresponding data from the above script, used for plotting
### * semantics_XY - corresponding semantics dataframe for the above data
#####################################################################################################################
### Outputs:
### * cluster_X_terms.Rdata files in a Q-dependent subfolder of dirOut
### * cluster_X_terms.png files in the same subfolder, showing the diagram of enriched terms for each cluster
### * cluster_X_<term_name>.png files in the same subfolder, showing the response profiles of term members within each cluster
#####################################################################################################################

dirCode <- paste0(ProteomicsToolkit::findgithub(), "/CCR5_APEX/")

############################################################################################################
### parse command line args
############################################################################################################
args <- R.utils::commandArgs(trailingOnly=TRUE, asValues=TRUE)
if (length(args) > 0) {
  l_Rdata.exists <- list() ; l_Rdata.exists[unlist(args[names(args)==""])] <- FALSE ; for (l in names(l_Rdata.exists)) l_Rdata.exists[l] <- file.exists(l) ; S_Rdata.paths <- names(l_Rdata.exists)[unlist(l_Rdata.exists)] ; rm(l_Rdata.exists)
  S_Rdata.paths <- S_Rdata.paths[grepl(".Rdata$", S_Rdata.paths)]
  load(S_Rdata.paths[1]) ; dirOut <- paste0(normalizePath(dirname(S_Rdata.paths[1])), "/")
  s_ont <- "" ; if ("ontology" %in% names(args)) s_ont <- args$ontology
  if (!(s_ont %in% c("Reactome", "GO.CC", "GO.BP", "GO.MF"))) { cat("Warning (08_GSEA_Cluster_Batches.R): unknown ontology", s_ont, "; will use the default instead\n\n") ; rm(s_ont) }
}
if (!exists("mmbr") || !is(mmbr, "data.frame")) stop("\nError: mmbr does not exist or is not a data frame\n\n")
if (!exists("cl_p.pVal") || !is(cl_p.pVal, "data.frame")) stop("\nError: cl_p.pVal does not exist or is not a data frame\n\n")
if (!exists("data_XY") || !is(data_XY, "data.frame")) stop("\nError: data_XY does not exist or is not a data frame\n\n")
if (!exists("semantics_XY") || !is(semantics_XY, "data.frame")) stop("\nError: semantics_XY does not exist or is not a data frame\n\n")
if (!exists("Q")) stop("\nError: Q does not exist\n\n")
if (!exists("dirOut")) stop("\nError: dirOut is undefined\n\n")

verbose <- TRUE
ncol.on.page <- 8

### the call below now defines a function, step08_ontologyEnAndOR(named.scores, score.cutoff, term_pValCutoff, l_prioritizeEnrichment=TRUE, l_multiACcheck=FALSE, verbose=TRUE)
source(paste0(dirCode, "08_ontologyEnAndOR_function.R"))

### also, define a function that forms a step08_ontologyEnAndOR() exclusively based on a cluster name
### this is redundant if executed in a single thread but necessary for the parallel implementation
step08_ontologyEnAndOR_onCluster <- function(clnm) { ### clnm is a cluster name

  calc.str <- "over-representation" ; if (l_prioritizeEnrichment) calc.str <- "enrichment/over-representation"
  cat(paste0("\n\n****************** Cluster ", clnm, ": analysing ", s_ont, " ", calc.str, " ******************\n"))

  ### form a name of the output, if the file exists, remove it
  if (clnm=="unclustered") ou08fnm <- paste0(ou08dir, "/unclustered_terms.Rdata") else ou08fnm <- paste0(ou08dir, "/cluster_", substr(as.character(10^n.char+as.numeric(clnm)), 2, 1+n.char), "_terms.Rdata")
  if (file.exists(ou08fnm)) { tmp <- do.call(file.remove, list(ou08fnm)) ; rm(tmp) }

  ### form the named list of scores and call the step08_ontologyEnAndOR() function
  #named.scores <- m[, clnm, drop=TRUE] ; names(named.scores) <- rownames(m)
  named.scores <- m[, clnm, drop=TRUE] ; names(named.scores) <- rownames(m) ### unlist(lapply(stringr::str_split(rownames(m), " "), "[[", 1))

  step08_result <- step08_ontologyEnAndOR(named.scores=named.scores, score.cutoff=p.pVal.cutoff, term_pValCutoff=term_pValCutoff, l_prioritizeEnrichment=l_prioritizeEnrichment, verbose=TRUE, s_ont=s_ont)

  ### extract fields from the step08_result structure and save
  # goEnplot <- step08_result$goEnplot ; goORplot <- step08_result$goORplot
  # ReEnplot <- step08_result$ReEnplot ; ReORplot <- step08_result$ReORplot
  # GO_enrichment <- step08_result$GO_enrichment ; GO_overrepresentation <- step08_result$GO_overrepresentation
  # Reactome_enrichment <- step08_result$Reactome_enrichment ; Reactome_overrepresentation <- step08_result$Reactome_overrepresentation
  Enrichment <- step08_result$Enrichment ; Overrepresentation <- step08_result$Overrepresentation ;
  df08 <- step08_result$df08 ; Enplot <- step08_result$Enplot ; ORplot <- step08_result$ORplot
  if (step08_result$error != "") cat(paste0("step08_ontologyEnAndOR() returned the following s_error: ", step08_result$error, "\n"))
  rm(step08_result)

  #if (file.access(ou08fnm, mode=2)<0) cat("\n Trying to save the results to", ou08fnm, "but have no writing permissions\n")
  #save(list=c("GO_enrichment", "GO_overrepresentation", "Reactome_enrichment", "Reactome_overrepresentation", "df08", "goEnplot", "goORplot", "ReEnplot", "ReORplot"), file=ou08fnm)
  save(list=c("Enrichment", "Overrepresentation", "df08", "Enplot", "ORplot"), file=ou08fnm)
} ### end defining step08_ontologyEnAndOR_onCluster() function

#####################################################################################################################

### what ontology are we going to use?
if (!exists("s_ont")){s_ont <- c("Reactome", "GO.CC", "GO.BP", "GO.MF")[3]}
term_pValCutoff <- 0.1

### are we working with the matrix of significance-adjusted memberships or the matrix of membership-adjusted significances?
l_p.pVals <- TRUE ; if (l_p.pVals) m <- cl_p.pVal else m <- mmbr

### create the output directory if it does not exist
ou08dir <- paste0(dirOut, "/terms_", Q, "_", s_ont) ; if (!dir.exists(ou08dir)) { dir.create(ou08dir, recursive=TRUE) }
n.char <- ceiling(log10(max(as.numeric(colnames(m)))+1)) ### an accessory variable for forming cluster-dependent file names with "001" or similar

### do we want to recalculate enrichment results or use the existing ones?
filenms <- list.files(ou08dir, full.names=TRUE) ; filenms <- filenms[grepl(".Rdata", filenms, fixed=TRUE)]
l_recalc.enrichments <- TRUE ; if (length(filenms)==0) l_recalc.enrichments <- TRUE ### If it's empty, no choice but to recalculate
l_prioritizeEnrichment <- TRUE ### if FALSE, go straight to OR calculations which are (good news) much faster and usually more productive and (bad news) not working in parallel threads

### OK let's do it now
if (l_recalc.enrichments) { ### recalculate - this takes a while
  ### clean up the output directory
  filenms <- list.files(ou08dir, full.names=TRUE) ; filenms <- filenms[grepl("[.]png|[.]Rdata", filenms, fixed=FALSE)] ; tmp <- do.call(file.remove, list(filenms)) ; rm(tmp)

  ### determine non-empty clusters - EnAndOR will only be analyzed for those that are non-empty
  calc.str <- "over-representation" ; if (l_prioritizeEnrichment) calc.str <- "enrichment/over-representation"
  clixs <- colnames(m) != "" ; names(clixs) <- colnames(m) ### indices of non-empty clusters ; initialize with all TRUEs
  for (cl in colnames(m)) {
    ### evaluate the # of cluster members above the specified significance of membership cutoff; if none, proceed to the next cluster
    if (l_p.pVals) n <- sum(m[, cl] > p.pVal.cutoff) else n <- sum(m[, cl] > memCutoff)
    if (l_p.pVals) {
      if (n < 1) { if (verbose) cat(paste0(" * Cluster ", cl ,": no members with p.pVal > ", format(p.pVal.cutoff, digits=4), "\n")) ; next }
      if (verbose) cat(paste0(" * Cluster ", cl ,": ", n, " member(s) with p.pVal > ", format(p.pVal.cutoff, digits=4),", calculating ", calc.str, "\n"))
    } else {
      if (n < 1) { if (verbose) cat(paste0(" * Cluster ", cl ,": no members with membership > ", format(memCutoff, digits=4), "\n")) ; next }
      if (verbose) cat(paste0(" * Cluster ", cl ,": ", n, " member(s) with membership > ", format(memCutoff, digits=4),", calculating ", calc.str, "\n"))
    }
    clixs[cl] <- (n > 0)
  }

  ##########################################################################################
  ### run the enrichment analysis either in a single thread or in three parallel threads ###
  ##########################################################################################
  nproc <- 1 ### number of parallel processes to run the En analysis in
  if (!l_prioritizeEnrichment) nproc <- 1 ### 2023-04-03 IK by some reason, OR analyses without prior attempts towards En do not work in parallel threads
                                          ### This may be because enrichGO() creates and overwrites some temp files but I cannot locate them and cannot figure out a way to redirect them
                                          ### I also cannot be sure En analysis work in multiple threads, given how frivolous clusterProfiler is with temp directories.
                                          ### Therefore, a safe way would be to just run everything in a single thread.
  if (nproc < 2) { ### 2023-03-31 the usual boring single-threaded loop
    for (clnm in colnames(m)) step08_ontologyEnAndOR_onCluster(clnm=clnm)
  } else { ### parallel execution. As of 2023-03-31, on IK's Skaggs 16-core Window's, this only works in no more than 3 threads.
    ### This is almost certainly because we are creating a parallel virtualCluster and calling clusterProfiler functions from its nodes,
    ### but clusterProfiler itself is creating a virtual cluster too, hence exceeding the number of computing cores.
    nproc <- 3 ### no more than that, otherwise run into the "cannot open the connection" error
    virtualCluster.oufnm <- paste0(ou08dir, "/virtualCluster.ou") ; if (file.exists(virtualCluster.oufnm)) { tmp <- do.call(file.remove, list(virtualCluster.oufnm)) ; rm(tmp) }
    virtualCluster <- parallel::makeCluster(min(floor(parallel::detectCores()/2), nproc), outfile=virtualCluster.oufnm)
    parallel::clusterExport(cl=virtualCluster,
                            varlist=c("dirOut", "dirCode", "step08_ontologyEnAndOR", "step08_ontologyEnAndOR_onCluster",
                                      "org.Hs.eg.db", "org.Mm.eg.db", "org.Rn.eg.db", "ID_to_ID",
                                      "Q", "m", "n.char", "p.pVal.cutoff", "term_pValCutoff", "s_ont", "ou08dir", "l_prioritizeEnrichment"),
                            envir=environment())
    tmp <- parallel::clusterApplyLB(cl=virtualCluster, x=colnames(m[clixs]), fun='step08_ontologyEnAndOR_onCluster')
    #tmp <- parallel::parLapply(cl=virtualCluster, X=colnames(m[clixs]), fun='step08_ontologyEnAndOR_onCluster', chunk.size=1)
    parallel::stopCluster(virtualCluster)
    nrow(installr::get_tasklist()) ### how many processes (all kinds of) currently?
    installr::kill_all_Rscript_s() ; nrow(installr::get_tasklist()) ### kill all Rscript processes and count total again
    #if (file.exists(virtualCluster.oufnm)) { tmp <- do.call(file.remove, list(virtualCluster.oufnm)) ; rm(tmp) } ### remove the  virtual cluster output file
  }
} ### end recalculating the enrichment analysis results
#####################################################################################################################

### Now plot
#s_mode <- c("GO_enrichment", "GO_overrepresentation", "Reactome_enrichment", "Reactome_overrepresentation")[2]
s_mode <- "Enrichment" ; if (!l_prioritizeEnrichment) s_mode <- "Overrepresentation"
if (!dir.exists(ou08dir)) { dir.create(ou08dir, recursive=TRUE) }
filenms <- list.files(ou08dir, full.names=TRUE) ; filenms <- filenms[grepl(".png", filenms, fixed=TRUE)] ; tmp <- do.call(file.remove, list(filenms)) ; rm(tmp, filenms)
nof.terms.in.clusters <- as.numeric(colnames(m)) ; names(nof.terms.in.clusters) <- colnames(m) ; nof.terms.in.clusters[1:length(nof.terms.in.clusters)] <- 0 ### initialize the summary of # of meaningful terms in each cluster
unique.terms <- NULL
for (cl in colnames(m)) {

  ### build the name for the Rdata file containing the enrichment analysis results; if the file does not exist, proceed to the next cluster
  if (cl=="unclustered") ou08fnm <- paste0(ou08dir, "/unclustered_terms.Rdata") else ou08fnm <- paste0(ou08dir, "/cluster_", substr(as.character(10^n.char+as.numeric(cl)), 2, 1+n.char), "_terms.Rdata")
  if (!file.exists(ou08fnm)) { cat(paste0(" * Cluster ", cl ," error: file ", ou08fnm, " does not exist\n")) ; next }
  load(file=ou08fnm) ; main.result <- get(s_mode)
  if (sum(grepl("enrichResult|gseaResult", is(main.result)))<1) { cat(paste0(" * Cluster ", cl ," error: no ", s_mode, " found in file ", ou08fnm, "\n")) ; next }

  result.type <- is(main.result)
  result <- main.result@result ### (ID, Description, setSize, enrichmentScore, NES, pvalue, p.adjust, qvalue, rank, leading_edge, core_enrichment)
  if (sum(result$p.adjust < term_pValCutoff) < 1) { cat(paste0(" * Cluster ", cl ," error: no significant terms in ", s_mode, "\n")) ; next }

  s_plotnm <- gsub("enrichment", "En", s_mode) ; s_plotnm <- gsub("overrepresentation", "OR", s_plotnm)
  s_plotnm <- gsub("Enrichment", "En", s_mode) ; s_plotnm <- gsub("Overrepresentation", "OR", s_plotnm)
  s_plotnm <- gsub("GO_", "go", s_plotnm) ;      s_plotnm <- gsub("Reactome_", "Re", s_plotnm)
  s_plotnm <- paste0(s_plotnm, "plot") ; eplot <- get(s_plotnm)

  # now have df08 (name, ENTREZID, SYMBOL, AC, score(=clustMem), GO_terms and/or Reactome_terms)
  # as well as result (this is an "enrichResult" or "gseaResult", it has ID, Description, and more)
  # as well as eplot (this is an enrichment plot)

  if (cl=="unclustered") oufnm <- paste0(ou08dir, "/unclustered_terms.png") else oufnm <- paste0(ou08dir, "/cluster_", substr(as.character(10^n.char+as.numeric(cl)), 2, 1+n.char), "_terms.png")
  if (sum(grepl("graph", is(eplot)))>0) ggplot2::ggsave(oufnm, eplot, width=12, height=12, units="in", scale=0.7, limitsize=FALSE)

  result <- result[result$p.adjust < term_pValCutoff, ] ; nof.terms.in.clusters[cl] <- nrow(result)
  unique.terms <- c(unique.terms, result$Description) ; termcolnm <- paste0(s_ont, ".terms")

  for (te in 1:nrow(result)) {

    term.member.names <- df08$name[grepl(paste0(";", result$Description[te], ";"), gsub("; ", ";", paste0("; ", df08[, termcolnm], "; ")), fixed=TRUE)] ### proteins in the current term

    ixs <- order(m[, cl], decreasing=TRUE)

    if (l_p.pVals) {
      opt <- 'p.pVal'
      ixs <- ixs[(data_XY$AC[ixs] %in% term.member.names) & (m[ixs, cl]>p.pVal.cutoff)] ### indices of these proteins in data_XY, in the order of decreasing significance
      n <- length(ixs) ; if (n<1) { cat(paste0(" * Cluster ", cl ,", ", result$Description[te], ": no members with p.pVal>", format(p.pVal.cutoff, digits=4), " in ", s_mode, "\n")) ; next
      } else { cat(paste0(" * Cluster ", cl ,", ", result$Description[te], ": ", n, " members with p.pVal>", format(p.pVal.cutoff, digits=4), " in ", s_mode, "; plotting...\n")) }
    } else {
      opt <- 'membership'
      ixs <- ixs[(data_XY$AC[ixs] %in% term.member.names) & (m[ixs, cl]>memCutoff)] ### indices of these proteins in data_XY, in the order of decreasing membership
      n <- length(ixs) ; if (n<1) { cat(paste0(" * Cluster ", cl ,", ", result$Description[te], ": no members with membership>", format(memCutoff, digits=4), " in ", s_mode, "\n")) ; next
      } else { cat(paste0(" * Cluster ", cl ,", ", result$Description[te], ": ", n, " members with membership>", format(memCutoff, digits=4), " in ", s_mode, "; plotting...\n")) }
    }

    colnm <- 'protein' ; if ('prot_site' %in% colnames(data_XY)) colnm <- 'prot_site'
    col_save  <- data_XY[, colnm] ; data_XY[, colnm] <- paste0(col_save, "\n", opt, "=", format(round(m[, cl], 2), scientific=FALSE, digits=2))
    g <- ProteomicsToolkit::plotPoint(data_XY[ixs, ], semantics_2, maxPoints=n, ncol=ncol.on.page, x_sqrt_scale = TRUE)
    data_XY[, colnm] <- col_save ; rm(colnm, col_save, opt)
    if (cl=="unclustered") oufnm <- paste0(ou08dir, "/unclustered_", make.names(result$Description[te]), ".png") else
      oufnm <- paste0(ou08dir, "/cluster_", substr(as.character(10^n.char+as.numeric(cl)), 2, 1+n.char), "_", make.names(result$Description[te]), ".png")
    ggplot2::ggsave(oufnm, g, width=ncol.on.page, height=ceiling(n/ncol.on.page), units="in", scale=3, limitsize=FALSE)
    if (n < 2) ggplot2::ggsave(oufnm, g, width=1, height=1, units="in", scale=3, limitsize=FALSE)
    if (result.type == "gseaResult") {oufnm <- gsub(".png", "_GSEA.png", oufnm) ; tmp <- enrichplot::gseaplot(main.result, geneSetID = te, title = result$Description[te]) ; suppressMessages(ggplot2::ggsave(oufnm, tmp))}
  }
  unique.terms <- unique(unique.terms)
} ### end plotting


if (verbose) { cat(paste0("\nInfo: non-empty ", s_mode, " found in ", sum(nof.terms.in.clusters>0), " cluster(s); ", sum(nof.terms.in.clusters), " terms total; ", length(unique.terms), " unique term(s)\n")) }

#####################################################
#################### UNUSED #########################
#####################################################

if (FALSE) { ### commands for testing background Rscript processes
  nrow(installr::get_tasklist()) ### how many processes (all kinds of) currently?
  system("Rscript -e repeat{2+2}", wait=FALSE) ; nrow(installr::get_tasklist()) ### spawn a new orphan Rscript process and count total again
  installr::kill_all_Rscript_s() ; nrow(installr::get_tasklist()) ### kill all Rscript processes and count total again
}

if (FALSE) { ### commands for manual spawning of Rscript background processes (does not work)
  ### save the necessary data into the input file:
  #save(list=c("ontodf", "l_multiACcheck", "term_pValCutoff", "score.cutoff", "l_prioritizeEnrichment", "verbose"), file=in08fnm)

  ### generate and invoke the shell command
  #cmdstr <- paste0(gsub("\\", "/", normalizePath(Sys.getenv('R_HOME')), fixed=TRUE), "/bin/Rscript.exe")
  #argstr <- c(paste0(dirCode, "08_ontologyEnAndOR_commandLine.R"), in08fnm)
  ##argstr <- shQuote(argstr, type=c("sh", "csh", "cmd", "cmd2"))
  #argstr <- shQuote(argstr, type="cmd") ### this works for Windows, need to figure out the right way for Unix and Mac
  #stdoutnm <- shQuote(gsub(".Rdata", ".out", ou08fnm), type="cmd") ### this works for Windows, need to figure out the right way for Unix and Mac
  #stderrnm <- shQuote(gsub(".Rdata", ".err", ou08fnm), type="cmd") ### this works for Windows, need to figure out the right way for Unix and Mac
  #errcode <- system2(cmdstr, args=argstr, stdout=stdoutnm, stderr=stderrnm, wait=FALSE)
}

if (FALSE) { ### desperate but unsuccessful attempts to determine what is passed to FUN by apply and lapply
  x <- m[, clnm, drop=FALSE];
  cat("\nx has", length(dim(x)), "dimensions:", paste0(dim(x), collapse="x"), "; x has length", length(x), "\n")
  cat("\nx has names", paste0(names(x)[1:10], collapse=", "), "...", "\n")
  cat("\nx equals", paste0(x[1:10], collapse=", "), "...", "\n")
}

### clear the environment
# nms <- c("calc.str", "cl", "cln", "clnm", "clixs", "df08", "termcolnm", "g")
# nms <- c(nms, "Enrichment", "GO_enrichment", "Reactome_enrichment", "Overrepresentation", "GO_overrepresentation", "Reactome_overrepresentation")
# nms <- c(nms, "eplot", "Enplot", "ReEnplot", "goEnplot", "ORplot", "ReORplot", "goORplot", "ixs", "l_prioritizeEnrichment", "l_p.pVals", "l_recalc.enrichments")
# nms <- c(nms, "m", "term.member.names", "verbose", "virtualCluster", "virtualCluster.oufnm", "n.char", "result", "s_mode", "s_ont", "s_plotnm", "nproc", "ou08dir", "ou08fnm", "oufnm", "te")
# nms <- nms[nms %in% ls()] ; if (length(nms)>0) rm(list=nms) ; rm(nms)
